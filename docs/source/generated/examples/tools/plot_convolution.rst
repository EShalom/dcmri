
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "generated\examples\tools\plot_convolution.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_generated_examples_tools_plot_convolution.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_generated_examples_tools_plot_convolution.py:


=====================================
A comparison of convolution functions
=====================================

Using the convolution functions `~dcmri.conv`, `~dcmri.expconv`, `~dcmri.stepconv`, `~dcmri.biexpconv` and `~dcmri.nexpconv`. 

.. GENERATED FROM PYTHON SOURCE LINES 10-16

.. code-block:: Python

    import time
    import numpy as np
    from scipy.stats import norm
    import matplotlib.pyplot as plt
    import dcmri as dc








.. GENERATED FROM PYTHON SOURCE LINES 17-20

Convolving any two functions
----------------------------
Generate two normalized gaussian distributions f(t) and h(t) and use `~dcmri.conv` to convolve them. Compare the result to `numpy.convolve`:

.. GENERATED FROM PYTHON SOURCE LINES 20-33

.. code-block:: Python

    t = np.linspace(0, 100, 50)
    f = norm.pdf(t, 30, 5)
    h = norm.pdf(t, 60, 10)
    g = dc.conv(h, f, t)
    g1 = np.convolve(h, f, mode='same')
    plt.plot(t, f, 'r-', label='f(t)')
    plt.plot(t, h, 'b-', label='h(t)')
    plt.plot(t, g, 'k-', label='dcmri.conv')
    plt.plot(g1, 'k:', label='numpy.convolve')
    plt.title('Convolution of two gaussian distributions')
    plt.legend()
    plt.show()




.. image-sg:: /generated/examples/tools/images/sphx_glr_plot_convolution_001.png
   :alt: Convolution of two gaussian distributions
   :srcset: /generated/examples/tools/images/sphx_glr_plot_convolution_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 34-35

While there is clearly some relation between both results, they are not in any way similar. The `~numpy.convolve` result is shifted compared to `~dcmri.conv` and has a lower amplitude. This shows that caution is needed when applying convolution formulae from different libraries in a tracer-kinetic setting.

.. GENERATED FROM PYTHON SOURCE LINES 38-41

Convolution with an exponential
-------------------------------
In the special case where one of the factors is an exponential function, the function `~dcmri.expconv` is more accurate than `~dcmri.conv`, though the difference is small at this time resolution:

.. GENERATED FROM PYTHON SOURCE LINES 41-53

.. code-block:: Python

    Tf = 20
    f = np.exp(-t/Tf)/Tf
    g0 = dc.conv(h, f, t)
    g1 = dc.expconv(h, Tf, t)
    plt.plot(t, f, 'r-', label='f(t)')
    plt.plot(t, h, 'b-', label='h(t)')
    plt.plot(t, g0, 'k-', label='conv()')
    plt.plot(t, g1, color='gray', linestyle='-', label='expconv()')
    plt.title('Comparison of conv() and expconv()')
    plt.legend()
    plt.show()




.. image-sg:: /generated/examples/tools/images/sphx_glr_plot_convolution_002.png
   :alt: Comparison of conv() and expconv()
   :srcset: /generated/examples/tools/images/sphx_glr_plot_convolution_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 54-55

However, `~dcmri.expconv` comes with a major improvement in computation time compared to `~dcmri.conv`. Hence `~dcmri.expconv` should be used instead of `~dcmri.conv` whenever applicable. We illustrate the effect by applying the functions 500 times and measuring the total computation time in each case. The acceleration is alomst 3 orders of magnitude:

.. GENERATED FROM PYTHON SOURCE LINES 55-64

.. code-block:: Python

    start = time.time()
    for _ in range(500):
        dc.conv(h, f, t)
    print('Computation time for conv(): ', time.time()-start, 'sec')
    start = time.time()
    for _ in range(500):
        dc.expconv(h, Tf, t)
    print('Computation time for expconv(): ', time.time()-start, 'sec')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Computation time for conv():  5.376615524291992 sec
    Computation time for expconv():  0.04188680648803711 sec




.. GENERATED FROM PYTHON SOURCE LINES 65-66

Incidentally since the time array in this case is uniform, `~dcmri.conv` can be accelerated by specifying dt instead of t in the arguments. However the performance remains far below `~dcmri.expconv`:

.. GENERATED FROM PYTHON SOURCE LINES 66-71

.. code-block:: Python

    start = time.time()
    for i in range(500):
        dc.conv(h, f, dt=t[1])
    print('Computation time for conv() with uniform times: ', time.time()-start, 'sec')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Computation time for conv() with uniform times:  2.553168535232544 sec




.. GENERATED FROM PYTHON SOURCE LINES 72-73

The difference in accuracy between `~dcmri.conv` and `~dcmri.expconv` becomes more apparent at lower temporal resolution but generally remains minor. Using 10 time points instead of 50 as above we start seeing some effect:

.. GENERATED FROM PYTHON SOURCE LINES 73-86

.. code-block:: Python

    t = np.linspace(0, 120, 10)
    h = norm.pdf(t, 60, 10)
    f = np.exp(-t/Tf)/Tf
    g0 = dc.conv(h, f, t)
    g1 = dc.expconv(h, Tf, t)
    plt.plot(t, f, 'r-', label='f(t)')
    plt.plot(t, h, 'b-', label='h(t)')
    plt.plot(t, g0, 'k-', label='conv()')
    plt.plot(t, g1, color='gray', linestyle='-', label='expconv()')
    plt.title('Comparison of conv() and expconv() at lower resolution')
    plt.legend()
    plt.show()




.. image-sg:: /generated/examples/tools/images/sphx_glr_plot_convolution_003.png
   :alt: Comparison of conv() and expconv() at lower resolution
   :srcset: /generated/examples/tools/images/sphx_glr_plot_convolution_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 87-90

Convolving two or more exponentials
-----------------------------------
If both functions are exponentials, convolution can be accelerated further with `~dcmri.biexpconv`, which uses an analytical formula to calculate the convolution: 

.. GENERATED FROM PYTHON SOURCE LINES 90-100

.. code-block:: Python

    Th = 10
    start = time.time()
    for i in range(1000):
        dc.expconv(h, Tf, t)
    print('Computation time for expconv(): ', time.time()-start, 'sec')
    start = time.time()
    for i in range(1000):
        dc.biexpconv(Th, Tf, t)
    print('Computation time for biexpconv(): ', time.time()-start, 'sec')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Computation time for expconv():  0.035901784896850586 sec
    Computation time for biexpconv():  0.017952919006347656 sec




.. GENERATED FROM PYTHON SOURCE LINES 101-102

The difference in computation time is small in this case, but using an analytical formula also comes with some improvements in accuracy. This is apparent at lower time resolution:

.. GENERATED FROM PYTHON SOURCE LINES 102-113

.. code-block:: Python

    h = np.exp(-t/Th)/Th
    g0 = dc.expconv(h, Tf, t)
    g1 = dc.biexpconv(Th, Tf, t)
    plt.plot(t, f, 'r-', label='f(t)')
    plt.plot(t, h, 'b-', label='h(t)')
    plt.plot(t, g0, 'k-', label='expconv()')
    plt.plot(t, g1, color='gray', linestyle='-', label='biexpconv()')
    plt.title('Comparison of expconv() and biexpconv()')
    plt.legend()
    plt.show()




.. image-sg:: /generated/examples/tools/images/sphx_glr_plot_convolution_004.png
   :alt: Comparison of expconv() and biexpconv()
   :srcset: /generated/examples/tools/images/sphx_glr_plot_convolution_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 114-115

The final convolution function `~dcmri.nexpconv` convolves n indentical exponentials with mean transit time T analytically. We illustrate the result by keeping the total mean transit time MTT=nT constant, and increasing n from 1 to 100. As the number of exponentials increases, the convolution converges to a delta function positioned on t=MTT:

.. GENERATED FROM PYTHON SOURCE LINES 115-128

.. code-block:: Python

    MTT = 30
    t = np.linspace(0, 120, 500)
    g1 = dc.nexpconv(1, MTT/1, t)
    g10 = dc.nexpconv(10, MTT/10, t)
    g100 = dc.nexpconv(100, MTT/100, t)
    plt.plot(t, g1, 'r-', label='1 exponential')
    plt.plot(t, g10, 'g-', label='10 exponentials')
    plt.plot(t, g100, 'b-', label='100 exponentials')
    plt.title('Convolutions of identical gaussian distributions')
    plt.legend()
    plt.show()
 




.. image-sg:: /generated/examples/tools/images/sphx_glr_plot_convolution_005.png
   :alt: Convolutions of identical gaussian distributions
   :srcset: /generated/examples/tools/images/sphx_glr_plot_convolution_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 129-132

Convolution with a step function
--------------------------------
`dcmri` also provides a dedicated function `~dcmri.stepconv` for convolution with a step function. We illustrate this function here and compare against `~dcmri.conv`:

.. GENERATED FROM PYTHON SOURCE LINES 132-152

.. code-block:: Python

    n = 15
    t = np.linspace(0, 120, n)
    f = norm.pdf(t, 30, 10)
    T, D = 45, 0.5
    # Construct a step function explicitly and use `~dcmri.conv`
    T0, T1 = T-D*T, T+D*T
    h = np.zeros(n)
    h[(t>=T0)*(t<=T1)] = 1/(T1-T0)
    g0 = dc.conv(h, f, t)
    # Convolve with a step function directly using `~dcmri.stepconv`
    g1 = dc.stepconv(f, T, D, t)
    # Compare results
    plt.plot(t, f, 'r-', label='f(t)')
    plt.plot(t, g0, 'k-', label='conv()')
    plt.plot(t, g1, color='gray', linestyle='-', label='stepconv()')
    plt.title('Comparison of conv() and stepconv()')
    plt.legend()
    plt.show()





.. image-sg:: /generated/examples/tools/images/sphx_glr_plot_convolution_006.png
   :alt: Comparison of conv() and stepconv()
   :srcset: /generated/examples/tools/images/sphx_glr_plot_convolution_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 153-154

As with `~dcmri.expconv` the difference between `~dcmri.stepconv` and `~dcmri.conv` is relatively small even for coarse time grids such as the above, but there is a more substantial gain in computation time: 

.. GENERATED FROM PYTHON SOURCE LINES 154-163

.. code-block:: Python

    start = time.time()
    for _ in range(500):
        dc.conv(h, f, t)
    print('Computation time for conv(): ', time.time()-start, 'sec')
    start = time.time()
    for _ in range(500):
        dc.stepconv(f, T, D, t)
    print('Computation time for stepconv(): ', time.time()-start, 'sec')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Computation time for conv():  0.6861634254455566 sec
    Computation time for stepconv():  0.3281211853027344 sec





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 10.109 seconds)


.. _sphx_glr_download_generated_examples_tools_plot_convolution.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_convolution.ipynb <plot_convolution.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_convolution.py <plot_convolution.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
